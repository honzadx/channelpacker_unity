#pragma kernel CSMain

#include "Includes/MaskPacking.hlsl"

struct ChannelData
{
    int2 size;
    int2 offset;
    float2 clamp;
    float2 clip;
    int mask;
    int samplingType;
    int invert;
    float scaler;
    float defaultValue;
};

StructuredBuffer<ChannelData> channelDataBuffer;
Texture2D inputR : register(t0);
Texture2D inputG : register(t1);
Texture2D inputB : register(t2);
Texture2D inputA : register(t3);
RWTexture2D<float4> result;

inline float ResolveChannel(uint index, uint2 id)
{   
    ChannelData channelData = channelDataBuffer[index];

    id -= channelData.offset;
    id = lerp(id, id % channelData.size , channelData.samplingType);

    int4 unpackedMask = UnpackMask(channelData.mask);

    float4 pixel = (index == 0) * inputR[id.xy]
                 + (index == 1) * inputG[id.xy]
                 + (index == 2) * inputB[id.xy]
                 + (index == 3) * inputA[id.xy];

    float textureValue = unpackedMask.r * pixel.r
                       + unpackedMask.g * pixel.g
                       + unpackedMask.b * pixel.b
                       + unpackedMask.a * pixel.a;
    
    int defaultMask = !(channelData.mask << 1) & 1;
    int textureMask = 1 - defaultMask;
    float result = lerp(channelData.defaultValue, textureValue, textureMask);
    result = lerp(result, 1 - result, channelData.invert);
    result = lerp(result, result * channelData.scaler, textureMask);
    float aboveMin = min(step(channelData.clip.x, result), 1);
    float belowMax = min(step(result, channelData.clip.y), 1);
    result = lerp(result, result * belowMax * aboveMin + (1 - belowMax) * 1, textureMask);
    result = lerp(result, clamp(result, channelData.clamp.x, channelData.clamp.y), textureMask);
    return result;
}
 
[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    result[id.xy] = float4
    (
        ResolveChannel(0, id.xy),
        ResolveChannel(1, id.xy),
        ResolveChannel(2, id.xy),
        ResolveChannel(3, id.xy)
    );
}
